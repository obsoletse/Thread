第二章--对象及变量的并发访问
本章知识点:
	synchronized对象监听器为Object(对象)时的使用;
	synchronized对象监听器为class(类--静态锁)时的使用;
	    1.this:相当于只有一把钥匙的多把锁,他可以锁住多个代码块,但是每次开锁只能一个,如果钥匙在其他代码块手上,那么新来的被锁的多个代码块就拿不到钥匙,进不了方自己的代码块
        2.object:每一个object相当于一把锁,那么不同的锁会有不同的钥匙,这样如果自己的锁不同,一样的锁没有被其他人占据,自己开始能进入代码块
        3.类.class:这是静态的锁,应为静态就带有this的含义,所以不能用this,而用类.class
	非线程安全是如何产生的;
	关键字volatile的主要作用;
	关键字volatile与synchronized的区别;

    同步和异步的区别?
        同步就是实时处理(打电话):执行完一个函数或者方法后，必须等待系统的返回值，这是程序处于阻塞状态，只有接受到消息了才可以继续执行;
        异步就是分时处理(收短信):执行完一个函数或者方法,不必等待系统的返回值,只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，
                       系统会自动触发委托的异步过程，从而完成一个完整的流程。

2.1 synchronized 同步方法或者对象:
	什么是非线程安全? 非线程安全就是多个线程对同一个对象中的实例变量进行并发访问时发生，产生的后果是数据脏读。
	synchronized 原理: synchronized 关键字代表对这个方法或者对象加锁; 当多个线程要访问这个对象时,每要用到这个方法都要检查有没有
	                   其他线程正在运行，有的话要等待正在使用synchronized加锁方法的这个对象访问完，才可以继续访问。
    底层原理:每个对象有一个监视器锁(monitor)。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，
            过程如下：如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。

    synchronized 用法:
        ①在方法声明前:例: synchronized public void addI();
        ②同步块对象: synchronized(this){...同步块};

	1.方法内的变量为线程安全:
	    方法内部变量私有，因此线程安全
	    demo2_1_1 result
            a set over!
            b set over!
            b num = 200
            a num = 100

	2.实例变量非线程安全:
	    多个线程访问同一个对象的实例变量，可能出现非线程安全
        demo2_1_2 result:
            a set over!
            b set over!
            b num = 200
            a num = 200---出现数据脏读

        解决办法:加synchronized关键字
        再次运行结果:
            a set over!
            a num = 100
            b set over!
            b num = 200---等待a线程执行完才可以访问
	
	3.多个对象多个锁(对象锁，类锁)
		例:两个线程分别访问同一个类的两个不同实例对象的相同名称的同步方法，效果以异步的方式运行
		原因:synchronized 关键字是取得的锁都是对象锁，而不是把一段代码或者方法当做锁，哪个线程先访问带有synchronized关键字的方法，哪个线程
		     就持有该对象的Lock，其他线程只能处于等待状态，当然前提是要同一个对象，多对象就会创建多个锁。
		demo2_1_3 result:
		    a set over!
            b set over!
            b num = 200
            a num = 100

    4.synchronized 与 锁对象
        1.多个线程在调用同一个对象的加了synchronized关键字时一定是是排队运行的，而未加synchronized关键字的方法可以同时异步调用
        △:只有需要共享的资源才需要加synchronized，如果不是则没有必要
        demo2_1_4 result:
            未加synchronized:(异步调用)
                begin methodA 的对象是:A
                begin methodA 的对象是:B
                end
                end
            加了synchronized:
                begin methodA 的对象是:A
                end
                begin methodA 的对象是:B
                end

        2.如何查看Lock锁对象的效果?
            result:
                methodB未加synchronized:
                    begin methodA 的对象是:A
                    begin methodB 的对象是:B
                    B begin time:1574685471374
                    A begin time:1574685471374
                    B end time:1574685473375
                    A end time:1574685475375

                methodB加了synchronized:
                    begin methodA 的对象是:A
                    A begin time:1574685677111
                    A end time:1574685681112
                    begin methodB 的对象是:B
                    B begin time:1574685681112
                    B end time:1574685683112
            结论:
                A先获得持有object对象的Lock锁，B可以通过异步的方式来获取object对象中非synchronized类型的方法
                A先获得持有object对象的Lock锁，B如果要调用object对象中synchronized类型的方法需要等待，即同步

    5.脏读:
        发生脏读的情况:在读取实例变量时，此值已经被其他线程修改过---原因:不同线程争抢实例变量的结果
        result:
            getValue method thread name = main username = B password = AA
            setValue method thread name = Thread-0 username = B password = BB
        解决办法:加synchronized关键字:
            setValue method thread name = Thread-0 username = B password = BB
            getValue method thread name = main username = B password = BB

    6.synchronized 锁重入
        关键字 synchronized 拥有锁重入的功能，也就是说当一个线程得到该对象的锁时，再次请求该对象的对象锁也是可以得到的，这也证明
        在一个synchronized方法/块内调用本类的其他synchronized方法/块时，是可以永远的得到锁的，否则会造成死锁
        demo2_1_6 result:
            Service1
            Service2
            Service3

        可重入锁也存在继承关系中:
            当子类继承父类时,是可以通过可重入锁来取得父类中的同步方法的;

    7.出现异常,锁自动释放:
        出现异常释放锁,其他线程可以获得这个同步锁对象
        demo2_1_7 result:a线程遇到异常,释放同步锁对象，线程B可以进入synchronized方法;
            ThreadName = a ，begin time = 1574749241554
            ThreadName = a ，exception time = 1574749242311
            Exception in thread "a" Thread B run time = 1574749242311
            java.lang.NumberFormatException: For input string: "a"
                at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
                at java.lang.Integer.parseInt(Integer.java:580)
                at java.lang.Integer.parseInt(Integer.java:615)
                at com.linbin.chatper01.demo2_1_7.Service.Service(Service.java:17)
                at com.linbin.chatper01.demo2_1_7.ThreadA.run(ThreadA.java:19)

    8.同步不具有继承性:
        synchronized不可以继承;---sub下没有同步，main有同步
            in Sub 下一步操作为sleep,当前线程 = A ,begin time = 1574752535240
            in Sub 下一步操作为sleep,当前线程 = B ,begin time = 1574752535241
            in Sub sleep操作完成,当前线程 = B ,end time = 1574752538242
            in Sub sleep操作完成,当前线程 = A ,end time = 1574752538242
            in main 下一步操作为sleep,当前线程 = B ,begin time = 1574752538242
            in main sleep操作完成,当前线程 = B ,end time = 1574752540242
            in main 下一步操作为sleep,当前线程 = A ,begin time = 1574752540242
            in main sleep操作完成,当前线程 = A ,end time = 1574752542243

2.2 synchronized 同步语句块:
    synchronized 同步语句块相比 synchronized 声明方法的优点?
        synchronized 声明方法时，存在一定的弊端,比如A线程调用同步方法执行一个较长时间的任务时，B线程就必须等待较长的时间，这种情况下可以用
        synchronized 同步语句块来解决;

    2.2.1 synchronized 声明方法的弊端:
        任务时间较长时，等待时间较长，从而导致消耗时间较长。

    2.2.2 synchronized 同步块的使用:
        synchronized(this){
            ...
        }

    2.2.3 synchronized 同步块解决synchronized声明方法的弊端:
        在需要同步的数据加上synchronized同步块即可;
        运行结果:
            begin task threadName = A--休眠3s(A,B任务异步同时提交，当A执行完B马上执行)
            begin task threadName = B--休眠3s
            长时间处理任务后返回值1 threadName = A
            长时间处理任务后返回值2 threadName = A
            end task threadName = A
            长时间处理任务后返回值1 threadName = B
            长时间处理任务后返回值2 threadName = B
            end task threadName = B
            耗时:3s

    2.2.4 一半同步，一半异步
        在synchronized同步块里同步，不在synchronized同步块里异步
        运行结果:
            no synchronized threadName = B i = 357
            no synchronized threadName = A i = 2393
            no synchronized threadName = B i = 358
            no synchronized threadName = A i = 2394

            synchronized threadName = A i = 5
            synchronized threadName = A i = 6
            synchronized threadName = A i = 7
            synchronized threadName = A i = 8


    2.2.5 synchronized 代码块之间的同步性验证
        在使用synchronized同步块时，其他线程对同一个对象中所有其他synchronized(this)的访问将会被阻塞。
        运行结果:
            ThreadName = A begin time = 1574832193132
            ThreadName = A end time = 1574832195172
            ThreadName = B begin time = 1574832195172
            ThreadName = B end time = 1574832197172

    2.2.6 验证synchronized(this)代码块也是锁定当前对象的
    异步打印:                                        同步打印:
        synchronized thread = Thread-0 i = 28           synchronized thread = Thread-0 i = 997
        synchronized thread = Thread-0 i = 29           synchronized thread = Thread-0 i = 998
        --- run otherMethod ---                         synchronized thread = Thread-0 i = 999
        synchronized thread = Thread-0 i = 30           synchronized thread = Thread-0 i = 1000
        synchronized thread = Thread-0 i = 31            --- run otherMethod ---
        synchronized thread = Thread-0 i = 998

    总结--synchronized和synchronized(this)的两种作用:
        (1)synchronized 方法:
            ①对其他synchronized同步方法或者synchronized(this)同步块的调用呈阻塞状态
            ②同一时间只有一个线程可以执行synchronized同步方法中的代码
        (2)synchronized(this) 同步块:
            ①对其他synchronized同步方法或者synchronized(this)同步块的调用呈阻塞状态
            ②同一时间只有一个线程可以执行synchronized(this)同步块中的代码

    2.2.7 将任意对象作为对象监视器
        synchronized(非this对象):
            (1)在多个线程持有对象监视器为同一个对象的前提下,同一时间只有一个线程可以执行同步块
            (2)在持有对象监视器为同一个对象的前提下,同一时间只有一个线程可以执行同步块(对象监视器不同，持有的对象锁不同，互相之间是异步的)

        (1)验证结果:此例锁的是this对象
            线程B在1574903286950进入同步块
            线程B在1574903289950离开同步块
            线程A在1574903289950进入同步块
            线程A在1574903292950离开同步块

        (2)验证结果:此例所得是非this对象--在synchronized同步块之外异步调用
            线程A在1574903540369进入同步块
            线程B在1574903540369进入同步块
            线程A在1574903543369离开同步块
            线程B在1574903543370离开同步块

        (3)验证synchronized(非this对象)和synchronized同步方法之间是异步调用的效果:
            methodA begin thread = Thread-0
            methodB begin thread = Thread-1
            methodB end thread = Thread-1
            methodA end thread = Thread-0

        (4)同步代码块放在非同步synchronized方法中声明，并不能保证线程的执行顺序，从而极易出现脏读
            △注意:就是调用同步方法是，也要放到同步代码块中
            运行结果:
                listSize = 2
                脏读出现原因:两个线程以异步的方式返回list参数size的大小，然后都添加了data
                解决方案:
                    在同步方法添加同步代码块
                    synchronized (list){
                        if (list.getListSize() < 1){
                            //TODO 模拟远程获取数据
                            Thread.sleep(2000);
                            list.add(data);
                        }
                    }
    2.2.8 细化验证3个结论:
        synchronized(非this对象x) 格式是将x对象本身作为对象监视器,这样就可以得出以下三个结论:
            ①当多个线程同时运行synchronized(x){}同步代码块呈同步效果;
            ②当其他线程执行x对象中的synchronized同步方法呈同步效果;
            ③当其他线程执行x对象中的synchronized(this)同步块方法呈同步效果

        验证①:(同步)
            testMethod1 __getLock time = 1574909299061 ,run thread = Thread-1
            testMethod1 __releaseLock time = 1574909301062 ,run thread = Thread-1
            testMethod1 __getLock time = 1574909301062 ,run thread = Thread-0
            testMethod1 __releaseLock time = 1574909303062 ,run thread = Thread-0

        验证②:(同步)
            testMethod1 __getLock time = 1574909600589 ,run thread = Thread-0
            testMethod1 __releaseLock time = 1574909602590 ,run thread = Thread-0
            我正在运行MyObject，begin = 1574909602590
            我正在运行MyObject，end = 1574909604590

        验证③(同步)
            testMethod1 __getLock time = 1574909757801 ,run thread = Thread-0
            testMethod1 __releaseLock time = 1574909759817 ,run thread = Thread-0
            我正在运行MyObject，begin = 1574909759817
            我正在运行MyObject，end = 1574909761817

    2.2.9静态同步synchronized方法和synchronized(*.class)代码块
        关键字synchronized还可以加在static静态方法上,如这样写，那是对当前的类进行加锁;与synchronized(*.class)效果一致;
        类锁和对象锁的区别:
            首先类锁和对象锁不是同一个锁，所以它们之间是异步调用的;
            /*
             *  非静态方法:
             *  给对象加锁(可以理解为给这个对象的内存上锁,注意 只是这块内存,其他同类对象都会有各自的内存锁),这时候
             * 在其他一个以上线程中执行该对象的这个同步方法(注意:是该对象)就会产生互斥

             *  静态方法:
             * 相当于在类上加锁(*.class 位于代码区,静态方法位于静态区域,这个类产生的对象公用这个静态方法,所以这块
             * 内存，N个对象来竞争), 这时候,只要是这个类产生的对象,在调用这个静态方法时都会产生互斥
             */
        简而言之:对象锁就是对象实例化可以有多个，每个对象持有不同锁，而对象不管实例化多少个都只有一个类锁，调用静态方法必须等待;

        _1:验证对象锁和类锁为不同锁:(A,C异步调用 , A,B同步)
            线程名称为:A在1574911071377进入printA
            线程名称为:C在1574911071377进入printC
            线程名称为:A在1574911073379离开printA
            线程名称为:C在1574911073379离开printC
            线程名称为:B在1574911073379进入printB
            线程名称为:B在1574911075379离开printB

        _2:Class锁对所有对象实例都起作用

    2.2.10 synchronized 和 String 常量池的特性
        在JVM中String常量池具有缓存的特性,将synchronized和String联合使用时，要注意常量池带来的例外:
        值相同时运行结果:
            当前执行的线程为:A
            当前执行的线程为:A
            当前执行的线程为:A
            当前执行的线程为:A

        值不同时运行结果:
            当前执行的线程为:A
            当前执行的线程为:B
            当前执行的线程为:A
            当前执行的线程为:B

        原因:String常量池具有缓存特性，当值相同时，它们持有相同的对象锁，则同步;当值不同时，它们持有不同的对象锁，则异步

    2.2.11 同步synchronized方法无限等待与解决:
        同步synchronized方法容易造成死循环。
        运行结果:
            methodA begin
        线程B永远得不到锁导致饿死

        解决办法:
            采用synchronized(object)对象监听器
        运行结果:B线程得到运行机会不会饿死
            methodA begin
            methodB begin
            methodB end

    2.2.12 多线程的死锁
        什么是死锁？
            死锁是因为不同线程都在等待根本不可能被释放的资源，从而导致所有任务都无法继续完成。多线程死锁必须避免，因为会造成线程假死
            在代码中:双方分别持有对方需要的锁造成死锁

        thread1等待thread2的lock2锁对象;thread2等待thread1的lock1锁对象，造成死锁
        运行结果:
            只打印
            username = a
            username = b

    2.2.13 内置类(内部类)的使用
        内置类和静态内置类的区别?
            内部类对象是以外部类对象存在为前提
            静态内置类和外部类没有关系。
        从字面上看，一个被称为静态嵌套类，一个被称为内部类。从字面的角度解释是这样的：什么是嵌套？嵌套就是我跟你没关系，自己可以完全独立存在，
        但是我就想借你的壳用一下，来隐藏一下我自己。什么是内部？内部就是我是你的一部分，我了解你，我知道你的全部，没有你就没有我。

        外部类、内部类区别联系:
            |内部类：
            　　-|静态内部类：不可访问外部的非静态资源
            　　　　-|但是可以有public static abstract class Demo
            　　-|成员内部类：可以访问外部所有资源，但是本身内部不可有静态属性（因为自己本身就需要依靠外部类的实例化）
            　　-|局部内部类：不可被访问修饰符和static修饰，只能访问final变量和形参
            　　　　-|局部静态内部类：在外部类的静态方法中
            　　　　-|局部内部类：在外部类的一般方法中
            　　-|匿名内部类：没有构造器，没有静态资源，无法被访问修饰符、static修饰；只能创建匿名内部类的一个实例；创建的时候一定是在new的后面

    2.2.14内置类和同步实验1:
        1.内置类中有两个同步的方法,使用的是不同的的锁,则结果是异步打印的。
        2.用同步代码块进行类锁,其他线程只能以同步的方式调用被锁类中的静态同步方法。

    2.2.16 锁对象的改变
        在将任务数据类型作为同步锁对象时，需要注意的是，是否有多个线程同时持有锁对象，如果有，则同步，如果分别获得锁对象，则是异步的
        运行结果:(锁对象改变，异步调用)
            Thread A begin at1574926459846 LOCK123
            Thread B begin at1574926459897 LOCK456
            Thread A end at1574926461889
            Thread B end at1574926461897

2.3 volatile 关键字
    关键字 volatile 的作用是使变量多个线程间可见

    2.3.1 关键字volatile与死循环
        死循环demo:
            无法运行start下面的代码;

    2.3.2解决同步死循环:多线程