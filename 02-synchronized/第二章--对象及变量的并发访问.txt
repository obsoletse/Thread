第二章--对象及变量的并发访问
本章知识点:
	synchronized对象监听器为Object(对象)时的使用;
	synchronized对象监听器为class(类--静态锁)时的使用;
	    1.this:相当于只有一把钥匙的多把锁,他可以锁住多个代码块,但是每次开锁只能一个,如果钥匙在其他代码块手上,那么新来的被锁的多个代码块就拿不到钥匙,进不了方自己的代码块
        2.object:每一个object相当于一把锁,那么不同的锁会有不同的钥匙,这样如果自己的锁不同,一样的锁没有被其他人占据,自己开始能进入代码块
        3.类.class:这是静态的锁,应为静态就带有this的含义,所以不能用this,而用类.class
	非线程安全是如何产生的;
	关键字volatile的主要作用;
	关键字volatile与synchronized的区别;

    同步和异步的区别?
        同步就是实时处理(打电话):执行完一个函数或者方法后，必须等待系统的返回值，这是程序处于阻塞状态，只有接受到消息了才可以继续执行;
        异步就是分时处理(收短信):执行完一个函数或者方法,不必等待系统的返回值,只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，
                       系统会自动触发委托的异步过程，从而完成一个完整的流程。

2.1 synchronized 同步方法或者对象:
	什么是非线程安全? 非线程安全就是多个线程对同一个对象中的实例变量进行并发访问时发生，产生的后果是数据脏读。
	synchronized 原理: synchronized 关键字代表对这个方法或者对象加锁; 当多个线程要访问这个对象时,每要用到这个方法都要检查有没有
	                   其他线程正在运行，有的话要等待正在使用synchronized加锁方法的这个对象访问完，才可以继续访问。
    底层原理:每个对象有一个监视器锁(monitor)。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，
            过程如下：如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。

    synchronized 用法:
        ①在方法声明前:例: synchronized public void addI();
        ②同步块对象: synchronized(this){...同步块};

	1.方法内的变量为线程安全:
	    方法内部变量私有，因此线程安全
	    demo2_1_1 result
            a set over!
            b set over!
            b num = 200
            a num = 100

	2.实例变量非线程安全:
	    多个线程访问同一个对象的实例变量，可能出现非线程安全
        demo2_1_2 result:
            a set over!
            b set over!
            b num = 200
            a num = 200---出现数据脏读

        解决办法:加synchronized关键字
        再次运行结果:
            a set over!
            a num = 100
            b set over!
            b num = 200---等待a线程执行完才可以访问
	
	3.多个对象多个锁(对象锁，类锁)
		例:两个线程分别访问同一个类的两个不同实例对象的相同名称的同步方法，效果以异步的方式运行
		原因:synchronized 关键字是取得的锁都是对象锁，而不是把一段代码或者方法当做锁，哪个线程先访问带有synchronized关键字的方法，哪个线程
		     就持有该对象的Lock，其他线程只能处于等待状态，当然前提是要同一个对象，多对象就会创建多个锁。
		demo2_1_3 result:
		    a set over!
            b set over!
            b num = 200
            a num = 100

    4.synchronized 与 锁对象
        1.多个线程在调用同一个对象的加了synchronized关键字时一定是是排队运行的，而未加synchronized关键字的方法可以同时异步调用
        △:只有需要共享的资源才需要加synchronized，如果不是则没有必要
        demo2_1_4 result:
            未加synchronized:(异步调用)
                begin methodA 的对象是:A
                begin methodA 的对象是:B
                end
                end
            加了synchronized:
                begin methodA 的对象是:A
                end
                begin methodA 的对象是:B
                end

        2.如何查看Lock锁对象的效果?
            result:
                methodB未加synchronized:
                    begin methodA 的对象是:A
                    begin methodB 的对象是:B
                    B begin time:1574685471374
                    A begin time:1574685471374
                    B end time:1574685473375
                    A end time:1574685475375

                methodB加了synchronized:
                    begin methodA 的对象是:A
                    A begin time:1574685677111
                    A end time:1574685681112
                    begin methodB 的对象是:B
                    B begin time:1574685681112
                    B end time:1574685683112
            结论:
                A先获得持有object对象的Lock锁，B可以通过异步的方式来获取object对象中非synchronized类型的方法
                A先获得持有object对象的Lock锁，B如果要调用object对象中synchronized类型的方法需要等待，即同步

    5.脏读:
        发生脏读的情况:在读取实例变量时，此值已经被其他线程修改过---原因:不同线程争抢实例变量的结果
        result:
            getValue method thread name = main username = B password = AA
            setValue method thread name = Thread-0 username = B password = BB
        解决办法:加synchronized关键字:
            setValue method thread name = Thread-0 username = B password = BB
            getValue method thread name = main username = B password = BB

    6.synchronized 锁重入
        关键字 synchronized 拥有锁重入的功能，也就是说当一个线程得到该对象的锁时，再次请求该对象的对象锁也是可以得到的，这也证明
        在一个synchronized方法/块内调用本类的其他synchronized方法/块时，是可以永远的得到锁的，否则会造成死锁
        demo2_1_6 result:
            Service1
            Service2
            Service3

        可重入锁也存在继承关系中:
            当子类继承父类时,是可以通过可重入锁来取得父类中的同步方法的;

    7.出现异常,锁自动释放:
        出现异常释放锁,其他线程可以获得这个同步锁对象
        demo2_1_7 result:a线程遇到异常,释放同步锁对象，线程B可以进入synchronized方法;
            ThreadName = a ，begin time = 1574749241554
            ThreadName = a ，exception time = 1574749242311
            Exception in thread "a" Thread B run time = 1574749242311
            java.lang.NumberFormatException: For input string: "a"
                at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
                at java.lang.Integer.parseInt(Integer.java:580)
                at java.lang.Integer.parseInt(Integer.java:615)
                at com.linbin.chatper01.demo2_1_7.Service.Service(Service.java:17)
                at com.linbin.chatper01.demo2_1_7.ThreadA.run(ThreadA.java:19)

    8.同步不具有继承性:
        synchronized不可以继承;---sub下没有同步，main有同步
            in Sub 下一步操作为sleep,当前线程 = A ,begin time = 1574752535240
            in Sub 下一步操作为sleep,当前线程 = B ,begin time = 1574752535241
            in Sub sleep操作完成,当前线程 = B ,end time = 1574752538242
            in Sub sleep操作完成,当前线程 = A ,end time = 1574752538242
            in main 下一步操作为sleep,当前线程 = B ,begin time = 1574752538242
            in main sleep操作完成,当前线程 = B ,end time = 1574752540242
            in main 下一步操作为sleep,当前线程 = A ,begin time = 1574752540242
            in main sleep操作完成,当前线程 = A ,end time = 1574752542243

2.2 synchronized 同步语句块:
    synchronized 同步语句块相比 synchronized 声明方法的优点?
        synchronized 声明方法时，存在一定的弊端,比如A线程调用同步方法执行一个较长时间的任务时，B线程就必须等待较长的时间，这种情况下可以用
        synchronized 同步语句块来解决;

    2.2.1 synchronized 声明方法的弊端:
        任务时间较长时，等待时间较长，从而导致消耗时间较长。

    2.2.2 synchronized 同步块的使用:
        synchronized(this){
            ...
        }

    2.2.3 synchronized 同步块解决synchronized声明方法的弊端:
        在需要同步的数据加上synchronized同步块即可;
        运行结果:
            begin task threadName = A--休眠3s(A,B任务异步同时提交，当A执行完B马上执行)
            begin task threadName = B--休眠3s
            长时间处理任务后返回值1 threadName = A
            长时间处理任务后返回值2 threadName = A
            end task threadName = A
            长时间处理任务后返回值1 threadName = B
            长时间处理任务后返回值2 threadName = B
            end task threadName = B
            耗时:3s

    2.2.4 一半同步，一半异步
        在synchronized同步块里同步，不在synchronized同步块里异步
        运行结果:
            no synchronized threadName = B i = 357
            no synchronized threadName = A i = 2393
            no synchronized threadName = B i = 358
            no synchronized threadName = A i = 2394

            synchronized threadName = A i = 5
            synchronized threadName = A i = 6
            synchronized threadName = A i = 7
            synchronized threadName = A i = 8


    2.2.5 synchronized 代码块之间的同步性验证
        在使用synchronized同步块时，其他线程对同一个对象中所有其他synchronized(this)的访问将会被阻塞。
        运行结果:
            ThreadName = A begin time = 1574832193132
            ThreadName = A end time = 1574832195172
            ThreadName = B begin time = 1574832195172
            ThreadName = B end time = 1574832197172

    2.2.6 验证synchronized(this)代码块也是锁定当前对象的
    异步打印:                                        同步打印:
        synchronized thread = Thread-0 i = 28           synchronized thread = Thread-0 i = 997
        synchronized thread = Thread-0 i = 29           synchronized thread = Thread-0 i = 998
        --- run otherMethod ---                         synchronized thread = Thread-0 i = 999
        synchronized thread = Thread-0 i = 30           synchronized thread = Thread-0 i = 1000
        synchronized thread = Thread-0 i = 31            --- run otherMethod ---
        synchronized thread = Thread-0 i = 998

    总结--synchronized和synchronized(this)的两种作用:
        (1)synchronized 方法:
            ①对其他synchronized同步方法或者synchronized(this)同步块的调用呈阻塞状态
            ②同一时间只有一个线程可以执行synchronized同步方法中的代码
        (2)synchronized(this) 同步块:
            ①对其他synchronized同步方法或者synchronized(this)同步块的调用呈阻塞状态
            ②同一时间只有一个线程可以执行synchronized(this)同步块中的代码

    2.2.7 将任意对象作为对象监视器